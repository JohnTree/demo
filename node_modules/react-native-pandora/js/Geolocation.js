import {requireNativeComponent, NativeModules, Platform, DeviceEventEmitter, PermissionsAndroid} from "react-native";
import React, {Component, PropTypes} from "react";


const _module = NativeModules.BaiduGeolocationModule;

export default {

    requestPermission  (permission)  {
        return PermissionsAndroid.request(
            permission
        );
    },
    doLocation()  {
        return new Promise((resolve, reject) => {
            try {
                UIManager.dispatchViewManagerCommand(
                    this.getWebViewHandle(),
                    UIManager.RCTBaiduMapView.Commands.gainLocation,
                    null
                );
            } catch (e) {
                reject(e);
                return;
            }
            DeviceEventEmitter.once('onGainLocationResult', resp => {
                resolve(resp);
            });
        });
    },
    getLocation()
    {
        if (Platform.OS === 'android') {
            return this.requestPermission("android.permission.ACCESS_COARSE_LOCATION", "定位").then(result => {
                if (result) {
                    return this.doLocation();
                } else {
                    return new Promise((resolve, reject) => {
                        reject({message: "定位失败"});
                    });
                }
            })
        } else {
            return this.doLocation();
        }
    }
    ,
    getCityPoi(city, keyword, pageIndex, pageCapacity)
    {
        return new Promise((resolve, reject) => {
            try {
                _module.getCityPoi(city, keyword, pageIndex, pageCapacity);
            } catch (e) {
                reject(e);
                return;
            }
            DeviceEventEmitter.once('onGetCityPoiResult', resp => {
                resolve(resp);
            });
        });
    }
    ,
    geocode(city, addr)
    {
        return new Promise((resolve, reject) => {
            try {
                _module.geocode(city, addr);
            }
            catch (e) {
                reject(e);
                return;
            }
            DeviceEventEmitter.once('onGetGeoCodeResult', resp => {
                resolve(resp);
            });
        });
    }
    ,
    reverseGeoCode(lat, lng)
    {
        return new Promise((resolve, reject) => {
            try {
                _module.reverseGeoCode(lat, lng);
            }
            catch (e) {
                reject(e);
                return;
            }
            DeviceEventEmitter.once('onGetReverseGeoCodeResult', resp => {
                resolve(resp);
            });
        });
    }
    ,
    reverseGeoCodeGPS(lat, lng)
    {
        return new Promise((resolve, reject) => {
            try {
                _module.reverseGeoCodeGPS(lat, lng);
            }
            catch (e) {
                reject(e);
                return;
            }
            DeviceEventEmitter.once('onGetReverseGeoCodeResult', resp => {
                resolve(resp);
            });
        });
    }
    ,
    getCurrentPosition()
    {
        if (Platform.OS == 'ios') {
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition((position) => {
                    _module.getBaiduCoorFromGPSCoor(position.coords.latitude, position.coords.longitude)
                        .then((data) => {
                            resolve(data);
                        })
                        .catch((e) => {
                            reject(e);
                        });
                }, (error) => {
                    reject(error);
                }, {
                    enableHighAccuracy: true,
                    timeout: 20000,
                    maximumAge: 1000
                });
            });
        }
        return new Promise((resolve, reject) => {
            try {
                _module.getCurrentPosition();
            }
            catch (e) {
                reject(e);
                return;
            }
            DeviceEventEmitter.once('onGetCurrentLocationPosition', resp => {
                resolve(resp);
            });
        });
    }
}
;